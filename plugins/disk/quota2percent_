#!/bin/bash
# -*- sh -*-
: <<=cut

=head1 NAME

quota2percent - Plugin to show disk usage in percent of quota hard limit.

=head1 APPLICABLE SYSTEMS

All systems with "bash", "quota", "repquota" and "munin"

=head1 CONFIGURATION

The following is the default configuration

  [quota2percent_*]
  user root

You could define two alert levels and the graph language

  [quota2percent_*]
  env.warning   [value]        (default: 90)
  env.critical  [value]        (default: 95)
  env.language  [en|de|es]     (default: en)   

=head1 DESCRIPTION

Wild card Plugin for monitoring the utilization of devices with quota rules. 
A graph is drawn for each user, which shows the usage as a percentage of his hard limit. System accounts (UID <1000) are suppressed. 
In addition, a graph is displayed which indicates the ratio device size to device coverage. 
The script repqutoa, usually part of the package quota, is needed. 
The plugin itself can be stored in any directory. For example, the device sdb1 shell be monitored, a symbolic link must be created
in the /etc/munin/plugins/ directory as follows: 

=over  

I<<<  ln -s /<path to file>/quota2percent_  quota2percent_sdb1 >>>

=back

=head1 MAGIC MARKERS

  #%# family=auto
  #%# capabilities=autoconf

=head1 VERSION

17.0131

=head1 HISTORY

V17.0131

  add    POD documentation
  add    env.language
  add    example graph for Munin Plugin Gallery
  remove German comments  

V17.0124

  first version, not munin rules conform

=head1 AUTHOR

Jo Hartmann

=head1 LICENSE
 
GPLv2 (L<http://www.gnu.org/licenses/gpl-2.0.html>)

=cut

###################################################
# Preparation section                             #
###################################################

# Load munin's shell libary
  . "$MUNIN_LIBDIR/plugins/plugin.sh"

# if any fetch from munin-node file
     Warning=${warning:-90}
     Critical=${critical:-95}
     Language=${language:-en}

# Ensure that the 'root' path is valid
  PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

# Checking if repquota installed and on the path
  repquota -V &> /dev/null
  if ! repquota -V &> /dev/null ; then
     echo "The script 'repquota' is not installed or on the path"
     # Send the exit code FATAL ERROR happens
     exit 127
  fi

# get tehe wild card text
  Id=${0##*_}

###################################################
# Data reading sections                           #
###################################################

# Reading the quotes for the selected device, using repquota 
  readarray Quotas < <( repquota "/dev/$Id" | grep " -- " )
  readarray Totals < <( df "/dev/$Id" )

# Get the count of Users 
   Users=${#Quotas[@]}


###################################################
# Munin Configuration Section                     #
###################################################

  if [ "$1" = "autoconf" ]; then
       echo yes
       exit 0
  fi


  if [ "$1" = "config" ]; then

     # Localisation of the graphic texts 
     case $Language in
          de)
            echo graph_title  "Quota-Hard-Limit von $Id"
            echo graph_vlabel "Nutzung in % Hardlimit"
            echo graph_info   "Die Grafik zeigt die Belegung des durch Quota reglementierten Speicherplatzes für alle regulären Nutzer (UID >=1000) in Prozent des Hardlimits."
            Total_txt="Su. aller Nutzer"
            Total_info="Inklusive Systemnutzer (UID < 1000)"
            ;;
          es) 
            echo graph_title  "Cuota de límite absoluto de $Id" 
            echo graph_vlabel "el % de uso del límite duro" 
            echo graph_info   "El gráfico muestra la disponibilidad de espacio regulado por cuotas para todos los usuarios regulares (UID> = 1000) como porcentaje de límites duros."
            Total_txt="Suma de todos los usuarios "
            Total_info="La inclusión de usuario del sistema (UID <1000) "
            ;;
           *)
            echo graph_title  "quota hard limit of $Id"
            echo graph_vlabel "Usage in %"
            echo graph_info   "The graphic shows the allocation of the quota-regulated storage space for all regular users (UID> = 1000) as a percentage of the hard limit ."
            Total_txt="all users"
            Total_info="system users (UID < 1000) included" 
            ;;
     esac

     # Defaults configuration 
       echo    graph_category disk
       echo    graph_args --lower-limit 0 --upper-limit 100
       echo    graph_printf %5.2lf %%
       echo    graph_scale  no

     # For each quota user fetch his real name, solve the root problem,  Output the configuration data 
       for((i=0; i<"$Users"; i++));do
         Quota=( ${Quotas[$i]} )
         UserName=${Quota[0]}
         #Passwd=$(cat /etc/passwd | grep $UserName)
         Passwd=$(grep "$UserName" /etc/passwd)
         OLDIFS=$IFS 
         IFS=':' Infos=($Passwd) 
         IFS=$OLDIFS
         UserInfo=${Infos[4]}
         UserInfo=${UserInfo%%,*}

         UserName="$(clean_fieldname "$UserName")"
         UserInfo="$(clean_fieldname "$UserInfo")"

         [ ! -n "$UserInfo"  ] && UserInfo="$UserName"
         [ "$(id -u "${Quota[0]}")" -lt 1000 ] && echo "$UserName.graph no"
         echo "$UserName.label $UserInfo"
         echo "$UserName.warning  $Warning"
         echo "$UserName.critical $Critical"
       done

     # configure the total line and send exit code NO ERROR happens
       echo total.label    "$Total_txt"
       echo total.warning  "$Warning"
       echo total.critical "$Critical"
       echo total.info     "$Total_info"
       exit 0
  fi

###################################################
# Munin value section                             #
###################################################

# fetch the needed values (used and hard limit) for each user, work around the root problem, calculate the percent value
  for((i=0; i<"$Users"; i++));do
    Quota=( ${Quotas[$i]} )
    UserName="$(clean_fieldname "${Quota[0]}")"
    echo "${Quota[2]} ${Quota[4]} $UserName.value" | awk '{printf "%s %.2f\n", $3 ,$1*100/$2}'
  done

# the value for the total line 
  Total=( ${Totals[1]} )
  echo "${Total[2]} ${Total[1]} total.value" | awk '{printf "%s %.2f\n", $3, $1*100/$2}'

# send the exit code NO ERROR happens
  exit 0

###################################################
# Script end                                      #
###################################################
